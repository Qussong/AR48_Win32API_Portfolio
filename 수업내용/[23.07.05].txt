
[ 오늘의 작업 ]

- CommonInclude.h 
	- 헤더 추가
		<string>
	- 멤버 추가
		namespace van::enums
		{
			enum class eLayer
			{
				Backgroiund,
				Player,
				Monster,
				Effect,
				UI,
				End,
			}
		}

- Entity 클래스 생성 (entity : 실제, 속성)
	- 멤버 추가
		[함수]
		void SetName(std::wstring name) { mName = name; }
		std::wstring& GetName() { return mName; } 
		[변수]
		wstring mName;
	- 상속 받오록 할 것이기에 소멸자에 virtual 키워드 사용
	
- Scene 클래스 생성
	- 멤버추가
		[함수]
		virtual void Initialize();
		virtual void Update();
		virtual void Render(HDC hdc);
		[변수]
		std::vector<Layer> mLayers;
			
- Layer 클래스 생성
	- 필요한 이유 : 이미지가 그려지는 순서를 조정하여 보여야 하는 객체가 안 보이는 경우가 안 생기게 하기 위해
	- 멤버 추가
		[함수]
		
		[멤버]
		//std::vector<GameObject*> mGameObjects;	// ★주소를 넘겨주는 이유 : 값 수정 해도 원본객체에 영향이 안간다. 그냥 이름만 알려주면 값 복사만 된다.

- GameObjects 클래스 생성
	- 멤버추가
		[함수]
		virtual void Initialize();
		virtual void Update();
		virtual void Render(HDC hdc);
		[변수]
		std::vector<Component> mComponents;
		
- Component 클래스 생성
	- 멤버추가	
		virtual void Initialize();
		virtual void Update();
		virtual void Render(HDC hdc);
	
- Transform 클래스 생성
	- 멤버추가	
		[함수]
		virtual void Initialize();
		virtual void Update();
		virtual void Render(HDC hdc);
		[변수]
		Vector2 mPosition;
		
- SpriteRenderer 클래스 생성
	- 멤버추가	
		[함수]
		
		[변수]
		
---

[ TextOut() ]
- 연산량이 많다. 다른거 써주자

---

[ 씬 ]
-	Unity : 씬
	Unreal : 레벨
	
---

[ for문의 새로운 형태 ]

아래의 case1 과 case2는 동일하다
	[case1]
	for(Layer& layer : mLayer)
	{
		// logic
	}
	
	[case2]
	for(int i = 0; i < mLayer.size(); ++i)
	{
		// logic
	}

---

[ 상용엔진 구조 ]
- Transeform
- Collide
- Render

---

[ override 키워드 ]
- 가독성을 위해서 넣어주는 키워드로 실제 기능에는 영향을 안끼친다.
- 해당 키워드가 안 붙어도 오버라이드 된다.

---

[ 라이프스타일 ]
Startup -> Updater -> Render (unity 기준, 이는 게임엔진마다 다르다.)

---

[ 순환참조 ]
- #include 를 잘못해주면 발생한다.

---

[다이나믹 캐스팅]
- 부모 자식간의 형 변환을 자유롭게 해주는 캐스팅 기법
- dynamic_cast<T>
- 자식타입과 T타입이 일치하면 주소를 반환하고 그렇지 않으면 nullptr 반환

---

[공부 순서]
- Application::Initialize() 에 중단점 두고 F11로 코드흐름 공부하기